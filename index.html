<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Utah Teapot - Raytracer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', monospace;
        }
        
        #main-wrapper {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        #game-container {
            border: 1px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            position: relative;
        }
        
        #controls-sidebar {
            color: #0f0;
            text-align: left;
            width: 220px;
        }

        .section-title {
            font-size: 14px;
            margin-bottom: 10px;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #0f0;
            margin-top: 20px;
        }
        .section-title:first-child { margin-top: 0; }

        .control-option {
            cursor: pointer;
            padding: 6px 10px;
            margin: 2px 0;
            border: 1px solid transparent;
            opacity: 0.6;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #0f0;
        }

        .control-option:hover {
            opacity: 1;
            text-shadow: 0 0 5px #0f0;
        }

        .control-option.active {
            opacity: 1;
            border: 1px solid #0f0;
            background-color: rgba(0, 255, 0, 0.1);
            font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }

        .bullet {
            width: 6px;
            height: 6px;
            border: 1px solid #0f0;
            margin-right: 10px;
            display: inline-block;
        }

        .active .bullet {
            background-color: #0f0;
            box-shadow: 0 0 5px #0f0;
        }
    </style>
</head>
<body>
    <div id="status" style="position: absolute; color: #0f0; top: 20px;">Building BVH...</div>
    
    <div id="main-wrapper">
        <div id="game-container"></div>

        <div id="controls-sidebar">
            <div class="section-title">Software Raster</div>
            <div class="control-option" data-mode="points">
                <span class="bullet"></span> Points
            </div>
            <div class="control-option" data-mode="wireframe">
                <span class="bullet"></span> Wireframe
            </div>
            <div class="control-option" data-mode="hidden-line">
                <span class="bullet"></span> Hidden Line
            </div>
            <div class="control-option active" data-mode="flat">
                <span class="bullet"></span> Flat Shaded
            </div>
            <div class="control-option" data-mode="gouraud">
                <span class="bullet"></span> Gouraud
            </div>
            <div class="control-option" data-mode="phong">
                <span class="bullet"></span> Phong
            </div>

            <div class="section-title">Software Raytrace</div>
            <div class="control-option" data-mode="raytrace">
                <span class="bullet"></span> Ray Tracer (BVH)
            </div>

            <div class="section-title">FX</div>
            <div class="control-option" data-fx="bloom">
                <span class="bullet"></span> Bloom
            </div>
            <div class="control-option" data-fx="scanlines">
                <span class="bullet"></span> Scanlines
            </div>
        </div>
    </div>
    
    <script src="node_modules/phaser/dist/phaser.min.js"></script>
    <script src="teapot_data.js"></script>
    <script>
        const statusEl = document.getElementById('status');
        let currentRenderMode = 'flat';
        let activeFX = { bloom: false, scanlines: false };

        document.querySelectorAll('[data-mode]').forEach(opt => {
            opt.addEventListener('click', () => {
                document.querySelectorAll('[data-mode]').forEach(o => o.classList.remove('active'));
                opt.classList.add('active');
                currentRenderMode = opt.getAttribute('data-mode');
            });
        });

        document.querySelectorAll('[data-fx]').forEach(opt => {
            opt.addEventListener('click', () => {
                const fx = opt.getAttribute('data-fx');
                activeFX[fx] = !activeFX[fx];
                opt.classList.toggle('active', activeFX[fx]);
                if (window.gameScene) window.gameScene.updateFX();
            });
        });

        // --- BVH & Raytracing Logic ---
        class AABB {
            constructor() {
                this.min = {x: Infinity, y: Infinity, z: Infinity};
                this.max = {x: -Infinity, y: -Infinity, z: -Infinity};
            }
            add(v) {
                this.min.x = Math.min(this.min.x, v[0]);
                this.min.y = Math.min(this.min.y, v[1]);
                this.min.z = Math.min(this.min.z, v[2]);
                this.max.x = Math.max(this.max.x, v[0]);
                this.max.y = Math.max(this.max.y, v[1]);
                this.max.z = Math.max(this.max.z, v[2]);
            }
            intersect(ray) {
                let tmin = (this.min.x - ray.ox) * ray.idx;
                let tmax = (this.max.x - ray.ox) * ray.idx;
                if (tmin > tmax) [tmin, tmax] = [tmax, tmin];

                let tymin = (this.min.y - ray.oy) * ray.idy;
                let tymax = (this.max.y - ray.oy) * ray.idy;
                if (tymin > tymax) [tymin, tymax] = [tymax, tymin];

                if ((tmin > tymax) || (tymin > tmax)) return false;
                if (tymin > tmin) tmin = tymin;
                if (tymax < tmax) tmax = tymax;

                let tzmin = (this.min.z - ray.oz) * ray.idz;
                let tzmax = (this.max.z - ray.oz) * ray.idz;
                if (tzmin > tzmax) [tzmin, tzmax] = [tzmax, tzmin];

                if ((tmin > tzmax) || (tzmin > tmax)) return false;
                return true;
            }
        }

        class BVHNode {
            constructor(tris) {
                this.aabb = new AABB();
                this.tris = tris;
                this.left = null;
                this.right = null;
                
                // Calc Bounds
                for (let t of tris) {
                    this.aabb.add(t.v0);
                    this.aabb.add(t.v1);
                    this.aabb.add(t.v2);
                }

                if (tris.length > 8) { // Split threshold
                    const axis = (this.aabb.max.x - this.aabb.min.x > this.aabb.max.y - this.aabb.min.y) ? 
                                 ((this.aabb.max.x - this.aabb.min.x > this.aabb.max.z - this.aabb.min.z) ? 0 : 2) : 
                                 ((this.aabb.max.y - this.aabb.min.y > this.aabb.max.z - this.aabb.min.z) ? 1 : 2);
                    
                    tris.sort((a,b) => a.center[axis] - b.center[axis]);
                    const mid = Math.floor(tris.length / 2);
                    this.left = new BVHNode(tris.slice(0, mid));
                    this.right = new BVHNode(tris.slice(mid));
                    this.tris = null; // Leaf only
                }
            }
        }

        class Raytracer {
            constructor(vertices, faces) {
                this.triangles = [];
                // Pre-process triangles for BVH
                // v0, v1, v2 are [x,y,z] arrays
                faces.forEach(f => {
                    const v0 = vertices[f[0]];
                    const v1 = vertices[f[1]];
                    const v2 = vertices[f[2]];
                    // Shift Y to center
                    const tv0 = [v0[0], v0[1]-1.5, v0[2]];
                    const tv1 = [v1[0], v1[1]-1.5, v1[2]];
                    const tv2 = [v2[0], v2[1]-1.5, v2[2]];
                    
                    const center = [
                        (tv0[0]+tv1[0]+tv2[0])/3,
                        (tv0[1]+tv1[1]+tv2[1])/3,
                        (tv0[2]+tv1[2]+tv2[2])/3
                    ];
                    
                    // Face Normal
                    const ux = tv1[0]-tv0[0], uy = tv1[1]-tv0[1], uz = tv1[2]-tv0[2];
                    const vx = tv2[0]-tv0[0], vy = tv2[1]-tv0[1], vz = tv2[2]-tv0[2];
                    let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                    const len = Math.sqrt(nx*nx+ny*ny+nz*nz);
                    const n = len>0 ? {x:nx/len, y:ny/len, z:nz/len} : {x:0,y:1,z:0};

                    this.triangles.push({v0:tv0, v1:tv1, v2:tv2, center, normal:n});
                });
                
                console.log("Building BVH for " + this.triangles.length + " triangles...");
                this.root = new BVHNode(this.triangles);
                console.log("BVH Built.");
            }

            intersect(ray, node) {
                if (!node.aabb.intersect(ray)) return null;
                
                let minHit = null;

                if (node.tris) {
                    // Leaf
                    for (let t of node.tris) {
                        // Moller-Trumbore
                        const v0 = t.v0, v1 = t.v1, v2 = t.v2;
                        const edge1x = v1[0] - v0[0], edge1y = v1[1] - v0[1], edge1z = v1[2] - v0[2];
                        const edge2x = v2[0] - v0[0], edge2y = v2[1] - v0[1], edge2z = v2[2] - v0[2];
                        
                        const hx = ray.dy * edge2z - ray.dz * edge2y;
                        const hy = ray.dz * edge2x - ray.dx * edge2z;
                        const hz = ray.dx * edge2y - ray.dy * edge2x;
                        
                        const a = edge1x * hx + edge1y * hy + edge1z * hz;
                        if (a > -0.00001 && a < 0.00001) continue;
                        
                        const f = 1.0 / a;
                        const sx = ray.ox - v0[0], sy = ray.oy - v0[1], sz = ray.oz - v0[2];
                        const u = f * (sx * hx + sy * hy + sz * hz);
                        if (u < 0.0 || u > 1.0) continue;
                        
                        const qx = sy * edge1z - sz * edge1y;
                        const qy = sz * edge1x - sx * edge1z;
                        const qz = sx * edge1y - sy * edge1x;
                        const v = f * (ray.dx * qx + ray.dy * qy + ray.dz * qz);
                        if (v < 0.0 || u + v > 1.0) continue;
                        
                        const tt = f * (edge2x * qx + edge2y * qy + edge2z * qz);
                        if (tt > 0.001) { // Epsilon for self-intersection
                            if (!minHit || tt < minHit.t) {
                                minHit = { t: tt, tri: t };
                            }
                        }
                    }
                } else {
                    // Branch
                    const hitL = this.intersect(ray, node.left);
                    const hitR = this.intersect(ray, node.right);
                    if (hitL && hitR) return hitL.t < hitR.t ? hitL : hitR;
                    if (hitL) return hitL;
                    if (hitR) return hitR;
                }
                return minHit;
            }
        }

        class TeapotScene extends Phaser.Scene {
            constructor() {
                super({ key: 'TeapotScene' });
                this.ready = false;
                window.gameScene = this;
            }

            create() {
                try {
                    this.vertices = teapotData.vertices;
                    this.faces = teapotData.faces;

                    // Calc Vertex Normals for Software Raster modes
                    this.vertexNormals = new Array(this.vertices.length).fill(0).map(() => ({x:0, y:0, z:0}));
                    this.faces.forEach(f => {
                        const v1 = this.vertices[f[0]], v2 = this.vertices[f[1]], v3 = this.vertices[f[2]];
                        const ux = v2[0]-v1[0], uy = v2[1]-v1[1], uz = v2[2]-v1[2];
                        const vx = v3[0]-v1[0], vy = v3[1]-v1[1], vz = v3[2]-v1[2];
                        let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                        this.vertexNormals[f[0]].x += nx; this.vertexNormals[f[0]].y += ny; this.vertexNormals[f[0]].z += nz;
                        this.vertexNormals[f[1]].x += nx; this.vertexNormals[f[1]].y += ny; this.vertexNormals[f[1]].z += nz;
                        this.vertexNormals[f[2]].x += nx; this.vertexNormals[f[2]].y += ny; this.vertexNormals[f[2]].z += nz;
                    });
                    this.vertexNormals.forEach(n => {
                        const len = Math.sqrt(n.x*n.x + n.y*n.y + n.z*n.z);
                        if (len>0) { n.x/=len; n.y/=len; n.z/=len; }
                    });

                    this.graphics = this.add.graphics();
                    this.fxGraphics = this.add.graphics().setDepth(1000);
                    
                    // Init Raytracer
                    this.raytracer = new Raytracer(this.vertices, this.faces);
                    this.rtTexture = this.textures.createCanvas('rt_out', 200, 150);
                    this.rtImage = this.add.image(400, 300, 'rt_out').setScale(4).setVisible(false);

                    this.rotationY = 0;
                    this.rotationX = -0.4;
                    this.ready = true;
                    statusEl.style.display = 'none';
                } catch (e) {
                    statusEl.innerText = "Error: " + e.message;
                }
            }

            updateFX() {
                const cam = this.cameras.main;
                if (activeFX.bloom) {
                    if (!this.bloomFX) this.bloomFX = cam.postFX.addBloom(0x00ff00, 1, 1, 2, 1.2);
                } else {
                    if (this.bloomFX) { cam.postFX.remove(this.bloomFX); this.bloomFX = null; }
                }
            }

            update(time, delta) {
                if (!this.ready) return;

                this.graphics.clear();
                this.fxGraphics.clear();
                if (activeFX.scanlines) {
                    this.fxGraphics.lineStyle(1, 0x000000, 0.4);
                    for (let i = 0; i < 600; i += 3) this.fxGraphics.lineBetween(0, i, 800, i);
                }

                this.rotationY -= 0.9 * (delta / 1000);

                if (currentRenderMode === 'raytrace') {
                    this.rtImage.setVisible(true);
                    this.graphics.setVisible(false);
                    this.renderRaytrace(time);
                } else {
                    this.rtImage.setVisible(false);
                    this.graphics.setVisible(true);
                    this.renderRaster(time);
                }
            }

            renderRaytrace(time) {
                const ctx = this.rtTexture.context;
                const width = 200;
                const height = 150;
                const id = ctx.createImageData(width, height);
                const data = id.data;

                // Rotate Camera & Light (Instead of Object)
                // Object is static at Identity.
                // Rotation Y = this.rotationY
                // Inverse Rotation Y = -this.rotationY
                // We keep X rotation fixed at -0.4 for simplicity or inverse that too.
                
                const rY = -this.rotationY;
                const rX = -this.rotationX; 
                
                // Basic Camera Rotation Logic
                const cosY = Math.cos(rY), sinY = Math.sin(rY);
                const cosX = Math.cos(rX), sinX = Math.sin(rX);
                
                // Light Pos (World)
                const lTime = time * 0.0015;
                let lx = Math.sin(lTime) * 10;
                let ly = -5;
                let lz = Math.cos(lTime) * 10;
                
                // Transform Light to Local Space (Rotate by rY, rX)
                // 1. Rotate Y
                let lx1 = lx * cosY - lz * sinY;
                let lz1 = lx * sinY + lz * cosY;
                // 2. Rotate X
                let ly2 = ly * cosX - lz1 * sinX;
                let lz2 = ly * sinX + lz1 * cosX;
                const localLightPos = {x:lx1, y:ly2, z:lz2};

                // Camera at 0,0,-10 world.
                // Transform Camera to Local
                let cx = 0, cy = 0, cz = -10;
                // Rot Y
                let cx1 = cx * cosY - cz * sinY;
                let cz1 = cx * sinY + cz * cosY;
                // Rot X
                let cy2 = cy * cosX - cz1 * sinX;
                let cz2 = cy * sinX + cz1 * cosX;
                const localCamPos = {x:cx1, y:cy2, z:cz2};

                // For every pixel
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const idx = (y * width + x) * 4;
                        
                        // Screen space -1 to 1
                        const u = (x / width) * 2 - 1;
                        const v = -((y / height) * 2 - 1) * (height/width); // Aspect ratio
                        
                        // Ray Dir (View Space)
                        let dx = u, dy = v, dz = 1; // Looking +Z in standard raytracing, but our cam is at -10 looking at 0.
                        // So dir is (u, v, 1) if cam is 0,0,-10?
                        // Let's assume standard perspective
                        // Normalize
                        const len = Math.sqrt(dx*dx+dy*dy+dz*dz);
                        dx/=len; dy/=len; dz/=len;

                        // Rotate Ray Dir to Local Space
                        let rdx1 = dx * cosY - dz * sinY;
                        let rdz1 = dx * sinY + dz * cosY;
                        let rdy2 = dy * cosX - rdz1 * sinX;
                        let rdz2 = dy * sinX + rdz1 * cosX;
                        
                        const ray = {
                            ox: localCamPos.x, oy: localCamPos.y, oz: localCamPos.z,
                            dx: rdx1, dy: rdy2, dz: rdz2,
                            idx: 1/rdx1, idy: 1/rdy2, idz: 1/rdz2
                        };

                        const hit = this.raytracer.intersect(ray, this.raytracer.root);
                        
                        if (hit) {
                            // Shading
                            const hitX = ray.ox + ray.dx * hit.t;
                            const hitY = ray.oy + ray.dy * hit.t;
                            const hitZ = ray.oz + ray.dz * hit.t;
                            
                            // Light Vector (Hit -> Light)
                            const lVecX = localLightPos.x - hitX;
                            const lVecY = localLightPos.y - hitY;
                            const lVecZ = localLightPos.z - hitZ;
                            const lDist = Math.sqrt(lVecX*lVecX+lVecY*lVecY+lVecZ*lVecZ);
                            const lDirX = lVecX/lDist, lDirY = lVecY/lDist, lDirZ = lVecZ/lDist;
                            
                            // Shadow Ray
                            const shadowRay = {
                                ox: hitX + lDirX*0.01, oy: hitY + lDirY*0.01, oz: hitZ + lDirZ*0.01,
                                dx: lDirX, dy: lDirY, dz: lDirZ,
                                idx: 1/lDirX, idy: 1/lDirY, idz: 1/lDirZ
                            };
                            
                            // Fast check: does shadow ray hit anything closer than the light?
                            const shadowHit = this.raytracer.intersect(shadowRay, this.raytracer.root);
                            const inShadow = (shadowHit && shadowHit.t < lDist);
                            
                            if (inShadow) {
                                // Ambient only
                                data[idx] = 0; data[idx+1] = 20; data[idx+2] = 0;
                            } else {
                                // Phong
                                const n = hit.tri.normal;
                                const dot = Math.max(0, n.x*lDirX + n.y*lDirY + n.z*lDirZ);
                                
                                // Specular
                                // View Dir (Hit -> Cam)
                                const vDirX = localCamPos.x - hitX;
                                const vDirY = localCamPos.y - hitY;
                                const vDirZ = localCamPos.z - hitZ;
                                const vLen = Math.sqrt(vDirX*vDirX+vDirY*vDirY+vDirZ*vDirZ);
                                const vx = vDirX/vLen, vy = vDirY/vLen, vz = vDirZ/vLen;
                                
                                // Half vector
                                const hx = lDirX+vx, hy = lDirY+vy, hz = lDirZ+vz;
                                const hLen = Math.sqrt(hx*hx+hy*hy+hz*hz);
                                const nh = Math.max(0, n.x*(hx/hLen) + n.y*(hy/hLen) + n.z*(hz/hLen));
                                const spec = Math.pow(nh, 30) * 0.8;
                                
                                const val = 0.1 + dot * 0.9;
                                data[idx] = Math.min(255, spec*255);
                                data[idx+1] = Math.min(255, val*255 + spec*255);
                                data[idx+2] = Math.min(255, spec*255);
                            }
                            data[idx+3] = 255;
                        } else {
                            data[idx+3] = 0; // Transparent BG
                        }
                    }
                }
                
                this.rtTexture.refresh();
            }

            renderRaster(time) {
                const cosY = Math.cos(this.rotationY), sinY = Math.sin(this.rotationY);
                const cosX = Math.cos(this.rotationX), sinX = Math.sin(this.rotationX);
                const centerX = 400, centerY = 300, globalScale = 75, cameraZ = 10;

                const processedVerts = new Array(this.vertices.length);
                const transformedNormals = new Array(this.vertices.length);

                for (let i = 0; i < this.vertices.length; i++) {
                    const v = this.vertices[i];
                    const n = this.vertexNormals[i];
                    
                    const rx1 = v[0]*cosY - v[2]*sinY, rz1 = v[0]*sinY + v[2]*cosY;
                    const ry2 = (v[1]-1.5)*cosX - rz1*sinX, rz2 = (v[1]-1.5)*sinX + rz1*cosX;
                    processedVerts[i] = { rx: rx1, ry: ry2, rz: rz2 };

                    const nx1 = n.x*cosY - n.z*sinY, nz1 = n.x*sinY + n.z*cosY;
                    const ny3 = n.y*cosX - nz1*sinX, nz3 = n.y*sinX + nz1*cosX;
                    transformedNormals[i] = { x: nx1, y: ny3, z: nz3 };

                    const depth = rz2 + cameraZ;
                    if (depth > 0.1) {
                        const s = globalScale * (cameraZ / depth);
                        processedVerts[i].x = centerX + rx1*s;
                        processedVerts[i].y = centerY - ry2*s;
                        processedVerts[i].z = rz2;
                    } else {
                        processedVerts[i] = null;
                    }
                }

                if (currentRenderMode === 'points') {
                    this.graphics.fillStyle(0x00ff00, 1);
                    processedVerts.forEach(p => { if (p) this.graphics.fillRect(p.x, p.y, 2, 2); });
                    return;
                }

                const facesToDraw = [];
                const lightTime = time * 0.0015;
                const lx = Math.sin(lightTime), ly = -0.5, lz = Math.cos(lightTime);
                const lLen = Math.sqrt(lx*lx+ly*ly+lz*lz);
                const lDir = {x:lx/lLen, y:ly/lLen, z:lz/lLen};

                for(let i=0; i<this.faces.length; i++) {
                    const f = this.faces[i];
                    const p1=processedVerts[f[0]], p2=processedVerts[f[1]], p3=processedVerts[f[2]];
                    if(!p1||!p2||!p3) continue;
                    const cp = (p2.x-p1.x)*(p3.y-p1.y)-(p2.y-p1.y)*(p3.x-p1.x);
                    if(currentRenderMode!=='wireframe' && cp<0) continue;
                    
                    let color = 0x00ff00;
                    if(['flat','gouraud','phong'].includes(currentRenderMode)) {
                        if (currentRenderMode === 'flat') {
                            const ux = p2.rx - p1.rx, uy = p2.ry - p1.ry, uz = p2.rz - p1.rz;
                            const vx = p3.rx - p1.rx, vy = p3.ry - p1.ry, vz = p3.rz - p1.rz;
                            let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
                            const nLen = Math.sqrt(nx*nx+ny*ny+nz*nz);
                            if(nLen>0) { nx/=nLen; ny/=nLen; nz/=nLen; }
                            const dot = Math.max(0, nx*-lDir.x + ny*-lDir.y + nz*-lDir.z);
                            const val = Math.floor((0.15 + dot*0.85)*255);
                            color = (val << 8);
                        } else {
                            let avgInt = 0, avgSpec = 0;
                            [f[0], f[1], f[2]].forEach(idx => {
                                const n = transformedNormals[idx];
                                const dot = Math.max(0, n.x*-lDir.x + n.y*-lDir.y + n.z*-lDir.z);
                                avgInt += dot;
                                if (currentRenderMode === 'phong') {
                                    const hx = -lDir.x, hy = -lDir.y, hz = -lDir.z - 1;
                                    const hLen = Math.sqrt(hx*hx + hy*hy + hz*hz);
                                    const ndoth = Math.max(0, n.x*(hx/hLen) + n.y*(hy/hLen) + n.z*(hz/hLen));
                                    avgSpec += Math.pow(ndoth, 30);
                                }
                            });
                            const gVal = Math.floor((0.15 + (avgInt/3)*0.85)*255);
                            const sVal = Math.floor((avgSpec/3)*255);
                            color = (sVal << 16) | (Math.min(255, gVal + sVal) << 8) | sVal;
                        }
                    }
                    facesToDraw.push({p1,p2,p3,avgZ:(p1.z+p2.z+p3.z)/3, color});
                }
                
                facesToDraw.sort((a,b)=>b.avgZ-a.avgZ).forEach(f=>{
                    if(currentRenderMode==='wireframe') {
                        this.graphics.lineStyle(1,0x00ff00,0.4).strokePoints([f.p1,f.p2,f.p3], true);
                    } else {
                        const isHL = currentRenderMode==='hidden-line';
                        this.graphics.fillStyle(isHL?0x000000:f.color, 1);
                        this.graphics.lineStyle(1, isHL?0x00ff00:f.color, 1);
                        this.graphics.fillPoints([f.p1,f.p2,f.p3], true);
                        this.graphics.strokePoints([f.p1,f.p2,f.p3], true);
                    }
                });
            }
        }
        
        new Phaser.Game({ type: Phaser.AUTO, width: 800, height: 600, backgroundColor: '#000', parent: 'game-container', scene: TeapotScene });
    </script>
</body>
</html>